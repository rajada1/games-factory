<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cyberpunk Hand Particles</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      overflow: hidden;
      background: #000;
      font-family: 'Orbitron', monospace;
    }
    
    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    canvas { display: block; }
    
    #webcam {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 240px;
      height: 180px;
      border: 2px solid #0ff;
      border-radius: 8px;
      transform: scaleX(-1);
      opacity: 0.8;
      z-index: 100;
    }
    
    /* HUD Corners */
    .hud {
      position: fixed;
      color: #0ff;
      font-size: 12px;
      text-shadow: 0 0 10px #0ff;
      z-index: 50;
      pointer-events: none;
    }
    
    .hud-tl { top: 20px; left: 20px; }
    .hud-tr { top: 20px; right: 20px; text-align: right; }
    .hud-bl { bottom: 20px; left: 20px; }
    .hud-br { bottom: 210px; right: 20px; text-align: right; }
    
    .hud-value { font-size: 16px; font-weight: bold; }
    
    /* Vignette */
    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.8) 100%);
      z-index: 10;
    }
    
    /* Scanlines */
    #scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 255, 255, 0.03) 2px,
        rgba(0, 255, 255, 0.03) 4px
      );
      z-index: 11;
      animation: scanlineMove 8s linear infinite;
    }
    
    @keyframes scanlineMove {
      0% { transform: translateY(0); }
      100% { transform: translateY(4px); }
    }
    
    /* Customization Panel */
    #customPanel {
      position: fixed;
      top: 80px;
      left: 20px;
      background: rgba(0, 20, 40, 0.85);
      border: 1px solid #0ff;
      border-radius: 8px;
      padding: 15px;
      z-index: 100;
      color: #0ff;
      font-size: 11px;
      width: 220px;
      max-height: 70vh;
      overflow-y: auto;
    }
    
    #customPanel h3 {
      margin-bottom: 10px;
      font-size: 14px;
      border-bottom: 1px solid #0ff;
      padding-bottom: 5px;
    }
    
    .control-group {
      margin-bottom: 12px;
    }
    
    .control-group label {
      display: block;
      margin-bottom: 4px;
      opacity: 0.8;
    }
    
    .control-group input[type="range"] {
      width: 100%;
      accent-color: #0ff;
    }
    
    .control-group input[type="text"] {
      width: 100%;
      background: rgba(0,0,0,0.5);
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px;
      border-radius: 4px;
      font-family: 'Orbitron', monospace;
    }
    
    .control-group input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid #0ff;
      background: transparent;
      cursor: pointer;
    }
    
    .control-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .color-preset {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }
    
    .color-preset:hover {
      transform: scale(1.2);
      border-color: #fff;
    }
    
    .toggle-panel {
      position: fixed;
      top: 20px;
      left: 160px;
      background: rgba(0, 20, 40, 0.85);
      border: 1px solid #0ff;
      color: #0ff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      z-index: 101;
      font-family: 'Orbitron', monospace;
      font-size: 11px;
    }
    
    .toggle-panel:hover {
      background: rgba(0, 255, 255, 0.2);
    }
    
    #customPanel.hidden {
      display: none;
    }
    
    /* Instructions */
    #instructions {
      position: fixed;
      bottom: 210px;
      left: 20px;
      background: rgba(0, 20, 40, 0.7);
      border: 1px solid #0ff;
      border-radius: 8px;
      padding: 10px 15px;
      color: #0ff;
      font-size: 10px;
      z-index: 50;
      max-width: 280px;
    }
    
    #instructions h4 {
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    #instructions ul {
      list-style: none;
      line-height: 1.6;
    }
    
    #instructions .finger-icon {
      display: inline-block;
      width: 20px;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="vignette"></div>
  <div id="scanlines"></div>
  
  <video id="webcam" autoplay playsinline></video>
  
  <!-- HUD Corners -->
  <div class="hud hud-tl">
    <div>FPS</div>
    <div class="hud-value" id="fps">60</div>
  </div>
  
  <div class="hud hud-tr">
    <div>PARTICLES</div>
    <div class="hud-value" id="particleCount">12000</div>
  </div>
  
  <div class="hud hud-bl">
    <div>LEFT HAND</div>
    <div class="hud-value" id="leftStatus">--</div>
  </div>
  
  <div class="hud hud-br">
    <div>RIGHT HAND</div>
    <div class="hud-value" id="rightStatus">--</div>
  </div>
  
  <button class="toggle-panel" onclick="togglePanel()">‚öôÔ∏è CUSTOMIZE</button>
  
  <!-- Customization Panel -->
  <div id="customPanel">
    <h3>‚ö° CUSTOMIZATION</h3>
    
    <div class="control-group">
      <label>Particle Count: <span id="particleCountVal">12000</span></label>
      <input type="range" id="particleCountSlider" min="3000" max="30000" value="12000" step="1000">
    </div>
    
    <div class="control-group">
      <label>Particle Size: <span id="particleSizeVal">2.4</span></label>
      <input type="range" id="particleSizeSlider" min="1" max="5" value="2.4" step="0.1">
    </div>
    
    <div class="control-group">
      <label>Return Speed: <span id="returnSpeedVal">0.16</span></label>
      <input type="range" id="returnSpeedSlider" min="0.02" max="0.3" value="0.16" step="0.01">
    </div>
    
    <div class="control-group">
      <label>Repulsion Force: <span id="repulsionVal">50</span></label>
      <input type="range" id="repulsionSlider" min="10" max="150" value="50" step="5">
    </div>
    
    <h3 style="margin-top: 15px;">üñêÔ∏è GESTURES</h3>
    
    <div class="control-group">
      <label>1 Finger Text:</label>
      <input type="text" id="text1" value="Hello">
      <div class="control-row" style="margin-top: 5px;">
        <input type="color" id="color1" value="#00FFFF">
        <div class="color-preset" style="background:#00FFFF" onclick="setColor(1,'#00FFFF')"></div>
        <div class="color-preset" style="background:#FF00FF" onclick="setColor(1,'#FF00FF')"></div>
        <div class="color-preset" style="background:#FFFF00" onclick="setColor(1,'#FFFF00')"></div>
      </div>
    </div>
    
    <div class="control-group">
      <label>2 Fingers Text:</label>
      <input type="text" id="text2" value="Gemini">
      <div class="control-row" style="margin-top: 5px;">
        <input type="color" id="color2" value="#FFFF00">
        <div class="color-preset" style="background:#FFFF00" onclick="setColor(2,'#FFFF00')"></div>
        <div class="color-preset" style="background:#00FF88" onclick="setColor(2,'#00FF88')"></div>
        <div class="color-preset" style="background:#FF6600" onclick="setColor(2,'#FF6600')"></div>
      </div>
    </div>
    
    <div class="control-group">
      <label>3 Fingers Text:</label>
      <input type="text" id="text3" value="BRASIL">
      <div class="control-row" style="margin-top: 5px;">
        <input type="color" id="color3" value="#FF00FF">
        <div class="color-preset" style="background:#FF00FF" onclick="setColor(3,'#FF00FF')"></div>
        <div class="color-preset" style="background:#00FFFF" onclick="setColor(3,'#00FFFF')"></div>
        <div class="color-preset" style="background:#FF0000" onclick="setColor(3,'#FF0000')"></div>
      </div>
    </div>
    
    <div class="control-group">
      <label>4 Fingers Text:</label>
      <input type="text" id="text4" value="GAMES">
      <div class="control-row" style="margin-top: 5px;">
        <input type="color" id="color4" value="#00FF88">
        <div class="color-preset" style="background:#00FF88" onclick="setColor(4,'#00FF88')"></div>
        <div class="color-preset" style="background:#8800FF" onclick="setColor(4,'#8800FF')"></div>
        <div class="color-preset" style="background:#FFFFFF" onclick="setColor(4,'#FFFFFF')"></div>
      </div>
    </div>
    
    <h3 style="margin-top: 15px;">üé® EFFECTS</h3>
    
    <div class="control-group">
      <label>Nebula Intensity: <span id="nebulaVal">1.0</span></label>
      <input type="range" id="nebulaSlider" min="0.3" max="2.0" value="1.0" step="0.1">
    </div>
    
    <div class="control-group">
      <label>Ball Spin Speed: <span id="spinVal">0.02</span></label>
      <input type="range" id="spinSlider" min="0.005" max="0.1" value="0.02" step="0.005">
    </div>
  </div>
  
  <!-- Instructions -->
  <div id="instructions">
    <h4>üéÆ HOW TO PLAY</h4>
    <ul>
      <li><span class="finger-icon">üëÜ</span> 1 finger ‚Üí Text 1</li>
      <li><span class="finger-icon">‚úåÔ∏è</span> 2 fingers ‚Üí Text 2</li>
      <li><span class="finger-icon">ü§ü</span> 3 fingers ‚Üí Text 3</li>
      <li><span class="finger-icon">üññ</span> 4 fingers ‚Üí Text 4</li>
      <li><span class="finger-icon">üñêÔ∏è</span> Open palm ‚Üí Catch Mode</li>
      <li><span class="finger-icon">üëâ</span> Right point ‚Üí Scatter</li>
      <li><span class="finger-icon">üôå</span> Both open ‚Üí BASKETBALL!</li>
    </ul>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // ============== CONFIG ==============
    let CONFIG = {
      particleCount: 12000,
      particleSize: 2.4,
      returnSpeed: 0.16,
      repulsionForce: 50,
      nebulaIntensity: 1.0,
      ballSpinSpeed: 0.02,
      texts: ['Hello', 'Gemini', 'BRASIL', 'GAMES'],
      colors: [0x00FFFF, 0xFFFF00, 0xFF00FF, 0x00FF88]
    };
    
    // ============== GLOBALS ==============
    let scene, camera, renderer, particles, particleGeometry, particleMaterial;
    let originalPositions = [];
    let currentPositions = [];
    let targetPositions = [];
    let velocities = [];
    
    let leftHand = null;
    let rightHand = null;
    let leftFingers = 0;
    let rightFingers = 0;
    
    let currentShape = 0; // 0 = random, 1-4 = text, 5 = catch
    let nebulaMode = false;
    let catchMode = false;
    let ballMode = false;
    let ballRotation = 0;
    
    let fps = 60;
    let frameCount = 0;
    let lastTime = performance.now();
    
    // ============== INIT THREE.JS ==============
    function initThree() {
      scene = new THREE.Scene();
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 300;
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById('container').appendChild(renderer.domElement);
      
      createParticles();
      
      window.addEventListener('resize', onResize);
    }
    
    function createParticles() {
      if (particles) {
        scene.remove(particles);
        particleGeometry.dispose();
        particleMaterial.dispose();
      }
      
      const count = CONFIG.particleCount;
      particleGeometry = new THREE.BufferGeometry();
      
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      
      originalPositions = [];
      currentPositions = [];
      targetPositions = [];
      velocities = [];
      
      const color = new THREE.Color(CONFIG.colors[0]);
      
      for (let i = 0; i < count; i++) {
        const x = (Math.random() - 0.5) * 400;
        const y = (Math.random() - 0.5) * 400;
        const z = (Math.random() - 0.5) * 50;
        
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
        
        originalPositions.push({ x, y, z });
        currentPositions.push({ x, y, z });
        targetPositions.push({ x, y, z });
        velocities.push({ x: 0, y: 0, z: 0 });
      }
      
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      particleMaterial = new THREE.PointsMaterial({
        size: CONFIG.particleSize,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true
      });
      
      particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);
      
      document.getElementById('particleCount').textContent = count;
    }
    
    // ============== TEXT TO PARTICLES ==============
    function getTextPositions(text) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = 512;
      canvas.height = 128;
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 75px Orbitron, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const positions = [];
      
      const scaleX = 0.8;
      const scaleY = 0.8;
      const offsetX = -canvas.width / 2 * scaleX;
      const offsetY = -canvas.height / 2 * scaleY;
      
      for (let y = 0; y < canvas.height; y += 2) {
        for (let x = 0; x < canvas.width; x += 2) {
          const i = (y * canvas.width + x) * 4;
          if (imageData.data[i] > 128) {
            positions.push({
              x: x * scaleX + offsetX,
              y: -y * scaleY - offsetY,
              z: 0
            });
          }
        }
      }
      
      return positions;
    }
    
    // ============== BASKETBALL POSITIONS ==============
    function getBallPositions(centerX, centerY, radius = 60) {
      const positions = [];
      const count = CONFIG.particleCount;
      
      // Fibonacci sphere distribution
      const goldenAngle = Math.PI * (3 - Math.sqrt(5));
      
      for (let i = 0; i < count; i++) {
        const y = 1 - (i / (count - 1)) * 2;
        const radiusAtY = Math.sqrt(1 - y * y);
        const theta = goldenAngle * i + ballRotation;
        
        const x = Math.cos(theta) * radiusAtY;
        const z = Math.sin(theta) * radiusAtY;
        
        positions.push({
          x: centerX + x * radius,
          y: centerY + y * radius,
          z: z * radius
        });
      }
      
      return positions;
    }
    
    // ============== UPDATE SHAPE ==============
    function updateShape(fingerCount, color) {
      const textPositions = getTextPositions(CONFIG.texts[fingerCount - 1] || 'Hello');
      const count = CONFIG.particleCount;
      const newColor = new THREE.Color(color);
      const colors = particleGeometry.attributes.color.array;
      
      for (let i = 0; i < count; i++) {
        if (i < textPositions.length) {
          const idx = i % textPositions.length;
          targetPositions[i] = { ...textPositions[idx] };
        } else {
          const idx = i % textPositions.length;
          targetPositions[i] = {
            x: textPositions[idx].x + (Math.random() - 0.5) * 20,
            y: textPositions[idx].y + (Math.random() - 0.5) * 20,
            z: (Math.random() - 0.5) * 30
          };
        }
        
        colors[i * 3] = newColor.r;
        colors[i * 3 + 1] = newColor.g;
        colors[i * 3 + 2] = newColor.b;
      }
      
      particleGeometry.attributes.color.needsUpdate = true;
    }
    
    // ============== NEBULA MODE ==============
    function activateNebula() {
      const count = CONFIG.particleCount;
      const intensity = CONFIG.nebulaIntensity;
      
      for (let i = 0; i < count; i++) {
        targetPositions[i] = {
          x: (Math.random() - 0.5) * 600 * intensity,
          y: (Math.random() - 0.5) * 400 * intensity,
          z: (Math.random() - 0.5) * 300 * intensity
        };
      }
    }
    
    // ============== BALL MODE ==============
    function updateBallMode(palmX, palmY) {
      const positions = getBallPositions(palmX, palmY);
      const count = CONFIG.particleCount;
      const orangeColor = new THREE.Color(0xFF6600);
      const blackColor = new THREE.Color(0x331100);
      const colors = particleGeometry.attributes.color.array;
      
      ballRotation += CONFIG.ballSpinSpeed;
      
      for (let i = 0; i < count; i++) {
        const pos = positions[i];
        const t = performance.now() * 0.01 + i * 0.1;
        const bounce = Math.abs(Math.sin(t * 0.5)) * 20;
        
        targetPositions[i] = {
          x: pos.x,
          y: pos.y + bounce,
          z: pos.z
        };
        
        // Ball lines (simplified)
        const isLine = Math.abs(Math.sin(i * 0.01)) < 0.1;
        const c = isLine ? blackColor : orangeColor;
        
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }
      
      particleGeometry.attributes.color.needsUpdate = true;
    }
    
    // ============== PHYSICS UPDATE ==============
    function updatePhysics() {
      const positions = particleGeometry.attributes.position.array;
      const count = CONFIG.particleCount;
      const returnSpeed = CONFIG.returnSpeed;
      const repulsion = CONFIG.repulsionForce;
      
      for (let i = 0; i < count; i++) {
        let tx = targetPositions[i].x;
        let ty = targetPositions[i].y;
        let tz = targetPositions[i].z;
        
        let cx = currentPositions[i].x;
        let cy = currentPositions[i].y;
        let cz = currentPositions[i].z;
        
        // Right hand repulsion (when pointing)
        if (rightHand && !nebulaMode && rightFingers < 5) {
          const handX = (0.5 - rightHand.x) * 400;
          const handY = (0.5 - rightHand.y) * 300;
          
          const dx = cx - handX;
          const dy = cy - handY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 80) {
            const force = (80 - dist) / 80 * repulsion;
            velocities[i].x += (dx / dist) * force;
            velocities[i].y += (dy / dist) * force;
            // Keep Z flat for planar repulsion
          }
        }
        
        // Apply velocity with damping
        cx += velocities[i].x;
        cy += velocities[i].y;
        cz += velocities[i].z;
        
        velocities[i].x *= 0.92;
        velocities[i].y *= 0.92;
        velocities[i].z *= 0.92;
        
        // Lerp to target
        cx += (tx - cx) * returnSpeed;
        cy += (ty - cy) * returnSpeed;
        cz += (tz - cz) * returnSpeed;
        
        currentPositions[i].x = cx;
        currentPositions[i].y = cy;
        currentPositions[i].z = cz;
        
        positions[i * 3] = cx;
        positions[i * 3 + 1] = cy;
        positions[i * 3 + 2] = cz;
      }
      
      particleGeometry.attributes.position.needsUpdate = true;
    }
    
    // ============== HAND DETECTION ==============
    function countFingers(landmarks) {
      const dominated = landmarks;
      let count = 0;
      
      // Thumb (special case - horizontal)
      if (landmarks[4].x < landmarks[3].x) count++;
      
      // Other fingers (vertical check)
      const fingerTips = [8, 12, 16, 20];
      const fingerPips = [6, 10, 14, 18];
      
      for (let i = 0; i < 4; i++) {
        if (landmarks[fingerTips[i]].y < landmarks[fingerPips[i]].y) {
          count++;
        }
      }
      
      return count;
    }
    
    function onHandResults(results) {
      leftHand = null;
      rightHand = null;
      leftFingers = 0;
      rightFingers = 0;
      
      if (results.multiHandLandmarks && results.multiHandedness) {
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const landmarks = results.multiHandLandmarks[i];
          const handedness = results.multiHandedness[i].label;
          const fingers = countFingers(landmarks);
          
          // Palm center (average of landmarks)
          const palm = landmarks[9]; // Middle finger base as palm center
          
          if (handedness === 'Left') {
            rightHand = palm; // Mirrored
            rightFingers = fingers;
          } else {
            leftHand = palm;
            leftFingers = fingers;
          }
        }
      }
      
      // Update HUD
      document.getElementById('leftStatus').textContent = leftHand ? `${leftFingers} FINGERS` : '--';
      document.getElementById('rightStatus').textContent = rightHand ? `${rightFingers} FINGERS` : '--';
      
      // State logic
      nebulaMode = rightFingers === 5;
      catchMode = leftFingers === 5;
      ballMode = nebulaMode && catchMode;
      
      if (ballMode && leftHand) {
        const palmX = (0.5 - leftHand.x) * 400;
        const palmY = (0.5 - leftHand.y) * 300;
        updateBallMode(palmX, palmY);
      } else if (nebulaMode) {
        activateNebula();
      } else if (leftHand && leftFingers >= 1 && leftFingers <= 4) {
        updateShape(leftFingers, CONFIG.colors[leftFingers - 1]);
      }
    }
    
    // ============== MEDIAPIPE SETUP ==============
    async function initMediaPipe() {
      const video = document.getElementById('webcam');
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 640, height: 480 } 
        });
        video.srcObject = stream;
        
        const hands = new Hands({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        
        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.7,
          minTrackingConfidence: 0.5
        });
        
        hands.onResults(onHandResults);
        
        const camera = new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 640,
          height: 480
        });
        
        camera.start();
      } catch (err) {
        console.error('Camera error:', err);
        alert('Please allow camera access to use this application.');
      }
    }
    
    // ============== ANIMATION LOOP ==============
    function animate() {
      requestAnimationFrame(animate);
      
      updatePhysics();
      renderer.render(scene, camera);
      
      // FPS counter
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
        document.getElementById('fps').textContent = fps;
      }
    }
    
    // ============== RESIZE ==============
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // ============== UI CONTROLS ==============
    function togglePanel() {
      document.getElementById('customPanel').classList.toggle('hidden');
    }
    
    function setColor(num, hex) {
      document.getElementById('color' + num).value = hex;
      CONFIG.colors[num - 1] = parseInt(hex.replace('#', '0x'));
    }
    
    function setupControls() {
      // Particle count
      document.getElementById('particleCountSlider').addEventListener('input', (e) => {
        CONFIG.particleCount = parseInt(e.target.value);
        document.getElementById('particleCountVal').textContent = CONFIG.particleCount;
        createParticles();
      });
      
      // Particle size
      document.getElementById('particleSizeSlider').addEventListener('input', (e) => {
        CONFIG.particleSize = parseFloat(e.target.value);
        document.getElementById('particleSizeVal').textContent = CONFIG.particleSize;
        particleMaterial.size = CONFIG.particleSize;
      });
      
      // Return speed
      document.getElementById('returnSpeedSlider').addEventListener('input', (e) => {
        CONFIG.returnSpeed = parseFloat(e.target.value);
        document.getElementById('returnSpeedVal').textContent = CONFIG.returnSpeed;
      });
      
      // Repulsion
      document.getElementById('repulsionSlider').addEventListener('input', (e) => {
        CONFIG.repulsionForce = parseFloat(e.target.value);
        document.getElementById('repulsionVal').textContent = CONFIG.repulsionForce;
      });
      
      // Nebula intensity
      document.getElementById('nebulaSlider').addEventListener('input', (e) => {
        CONFIG.nebulaIntensity = parseFloat(e.target.value);
        document.getElementById('nebulaVal').textContent = CONFIG.nebulaIntensity;
      });
      
      // Ball spin
      document.getElementById('spinSlider').addEventListener('input', (e) => {
        CONFIG.ballSpinSpeed = parseFloat(e.target.value);
        document.getElementById('spinVal').textContent = CONFIG.ballSpinSpeed;
      });
      
      // Text inputs
      for (let i = 1; i <= 4; i++) {
        document.getElementById('text' + i).addEventListener('input', (e) => {
          CONFIG.texts[i - 1] = e.target.value;
        });
        
        document.getElementById('color' + i).addEventListener('input', (e) => {
          CONFIG.colors[i - 1] = parseInt(e.target.value.replace('#', '0x'));
        });
      }
    }
    
    // ============== INIT ==============
    window.onload = () => {
      initThree();
      setupControls();
      initMediaPipe();
      animate();
    };
  </script>
</body>
</html>
