<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pixel Stack</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; 
      height: 100%; 
      overflow: hidden;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #game-container {
      width: 100%;
      height: 100%;
      max-width: 500px;
      position: relative;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }
    .score {
      font-size: 28px;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    .best-score {
      font-size: 14px;
      color: rgba(255,255,255,0.8);
    }
    .game-over {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    .game-over.show {
      opacity: 1;
      pointer-events: auto;
    }
    .game-over h1 {
      color: white;
      font-size: 36px;
      margin-bottom: 10px;
    }
    .game-over .final-score {
      color: #e74c3c;
      font-size: 48px;
      font-weight: bold;
      margin-bottom: 30px;
    }
    .btn {
      background: #e74c3c;
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 18px;
      border-radius: 30px;
      cursor: pointer;
      margin: 5px;
      transition: transform 0.1s, opacity 0.1s;
    }
    .btn:active {
      transform: scale(0.95);
      opacity: 0.9;
    }
    .btn-secondary {
      background: transparent;
      border: 2px solid white;
    }
    .start-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .start-screen h1 {
      color: white;
      font-size: 32px;
      margin-bottom: 20px;
      text-align: center;
    }
    .start-screen .tap-to-start {
      color: rgba(255,255,255,0.7);
      font-size: 18px;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    .particles {
      position: absolute;
      pointer-events: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>
    <div class="ui-overlay">
      <div>
        <div class="score" id="score">0</div>
        <div class="best-score">Best: <span id="best">0</span></div>
      </div>
    </div>
    <div class="start-screen" id="start-screen">
      <h1>Pixel Stack</h1>
      <p class="tap-to-start">Toque para jogar</p>
    </div>
    <div class="game-over" id="game-over">
      <h1>Game Over</h1>
      <div class="final-score" id="final-score">0</div>
      <button class="btn" id="play-again">Jogar Novamente</button>
      <button class="btn btn-secondary" id="share">Compartilhar</button>
    </div>
    <div class="particles" id="particles"></div>
  </div>
  <script>
    // Stack Tower Game Logic
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over');
const finalScoreEl = document.getElementById('final-score');

function resize() {
  const container = document.getElementById('game-container');
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
}
resize();
window.addEventListener('resize', resize);

let gameState = 'start';
let score = 0;
let best = parseInt(localStorage.getItem('pixel-stack_best') || '0');
bestEl.textContent = best;

const blockHeight = 30;
let blocks = [];
let currentBlock = null;
let direction = 1;
let speed = 3;
let cameraY = 0;

const colors = [
  '#e74c3c', '#e67e22', '#f1c40f', '#2ecc71', '#1abc9c',
  '#3498db', '#9b59b6', '#e91e63', '#00bcd4', '#ff5722'
];

function init() {
  blocks = [];
  score = 0;
  scoreEl.textContent = '0';
  speed = 3;
  cameraY = 0;
  
  // Base block
  blocks.push({
    x: canvas.width / 2 - 100,
    width: 200,
    y: canvas.height - 100,
    color: colors[0]
  });
  
  spawnBlock();
}

function spawnBlock() {
  const lastBlock = blocks[blocks.length - 1];
  
  currentBlock = {
    x: -lastBlock.width,
    width: lastBlock.width,
    y: lastBlock.y - blockHeight,
    color: colors[(blocks.length) % colors.length],
    moving: true
  };
  
  direction = 1;
}

function placeBlock() {
  if (!currentBlock || !currentBlock.moving) return;
  
  currentBlock.moving = false;
  const lastBlock = blocks[blocks.length - 1];
  
  // Calculate overlap
  const overlapStart = Math.max(currentBlock.x, lastBlock.x);
  const overlapEnd = Math.min(currentBlock.x + currentBlock.width, lastBlock.x + lastBlock.width);
  const overlapWidth = overlapEnd - overlapStart;
  
  if (overlapWidth <= 0) {
    // Missed completely
    gameOver();
    return;
  }
  
  // Perfect placement bonus
  const perfectThreshold = 5;
  if (Math.abs(currentBlock.x - lastBlock.x) < perfectThreshold && 
      Math.abs(currentBlock.width - lastBlock.width) < perfectThreshold) {
    score += 2;
    playSound('perfect');
    // Grow block slightly on perfect
    currentBlock.width = Math.min(currentBlock.width + 5, 200);
    currentBlock.x = lastBlock.x - 2.5;
  } else {
    // Trim block to overlap
    currentBlock.x = overlapStart;
    currentBlock.width = overlapWidth;
    playSound('place');
  }
  
  blocks.push(currentBlock);
  score++;
  scoreEl.textContent = score;
  
  // Increase speed
  if (score % 5 === 0) {
    speed += 0.3;
  }
  
  // Camera follow
  const targetCameraY = Math.max(0, (blocks.length - 10) * blockHeight);
  
  spawnBlock();
}

function update() {
  if (gameState !== 'playing') return;
  
  if (currentBlock && currentBlock.moving) {
    currentBlock.x += speed * direction;
    
    // Bounce off walls
    if (currentBlock.x + currentBlock.width > canvas.width) {
      direction = -1;
    } else if (currentBlock.x < 0) {
      direction = 1;
    }
  }
  
  // Smooth camera
  const targetCameraY = Math.max(0, (blocks.length - 12) * blockHeight);
  cameraY += (targetCameraY - cameraY) * 0.1;
}

function draw() {
  // Background gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#0f0c29');
  gradient.addColorStop(0.5, '#302b63');
  gradient.addColorStop(1, '#24243e');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.save();
  ctx.translate(0, cameraY);
  
  // Draw blocks
  for (const block of blocks) {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(block.x + 5, block.y + 5, block.width, blockHeight);
    
    // Block
    ctx.fillStyle = block.color;
    ctx.fillRect(block.x, block.y, block.width, blockHeight);
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(block.x, block.y, block.width, 5);
  }
  
  // Draw current block
  if (currentBlock) {
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(currentBlock.x + 5, currentBlock.y + 5, currentBlock.width, blockHeight);
    
    ctx.fillStyle = currentBlock.color;
    ctx.fillRect(currentBlock.x, currentBlock.y, currentBlock.width, blockHeight);
    
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(currentBlock.x, currentBlock.y, currentBlock.width, 5);
  }
  
  ctx.restore();
}

function gameOver() {
  gameState = 'over';
  playSound('fall');
  
  if (score > best) {
    best = score;
    localStorage.setItem('pixel-stack_best', best);
    bestEl.textContent = best;
  }
  
  finalScoreEl.textContent = score;
  gameOverScreen.classList.add('show');
  
  if (navigator.vibrate) navigator.vibrate(100);
}

function restart() {
  gameOverScreen.classList.remove('show');
  gameState = 'playing';
  init();
}

function tap() {
  if (gameState === 'start') {
    startScreen.style.display = 'none';
    gameState = 'playing';
    init();
    return;
  }
  
  if (gameState === 'playing') {
    placeBlock();
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Sound
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  switch(type) {
    case 'place':
      osc.frequency.setValueAtTime(400 + score * 10, audioCtx.currentTime);
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
      break;
    case 'perfect':
      osc.frequency.setValueAtTime(600, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.2);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
      break;
    case 'fall':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.5);
      break;
  }
}

// Controls
document.addEventListener('touchstart', (e) => {
  e.preventDefault();
  tap();
}, { passive: false });

document.addEventListener('mousedown', tap);
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') tap();
});

document.getElementById('play-again').addEventListener('click', restart);
document.getElementById('share').addEventListener('click', () => {
  const text = `Empilhei ${score} blocos em Pixel Stack! üèóÔ∏è`;
  if (navigator.share) {
    navigator.share({ title: 'Pixel Stack', text });
  } else {
    navigator.clipboard.writeText(text);
    alert('Copiado!');
  }
});

gameLoop();

  </script>
</body>
</html>
